##

## 1. 上拉加载更多

```javascript
// 可视区高度
let clientHeight = document.documentElement.clientHeight

// 长度
let scrollHeight = document.body.scrollHeight

window.addEventListener('scroll', function (e) {
    // window窗口距离 顶部的距离
    let scrollTop = document.documentElement.scrollTop
    if (scrollTop + clientHeight >= scrollHeight) {
        console.log('上拉')
    }
})
```

## 2. 拖拽到指定位置 上传文件

```html
<div id="drop_area">
    <div class="box">将您的产品附件拖拽到此处</div>
    <input class="upload" type="file" name="name" multiple="multiple" />

    <div>请将文件控制在 100MB 以内</div>
</div>
```

```javascript
let box = document.querySelector('.box')

// 拖离
document.addEventListener('drop', function (e) {
    e.preventDefault()
})

// 拖后放
document.addEventListener('dragleave', function (e) {
    e.preventDefault()
})

// 拖进
document.addEventListener('dragenter', function (e) {
    e.preventDefault()
})

// 拖来拖去
document.addEventListener('dragover', function (e) {
    e.preventDefault()
})

box.addEventListener('drop', function (e) {
    // let fileList = [].slice.call(event.dataTransfer.files)   // es5 格式
    let fileList = Array.from(e.dataTransfer.files) // es6 格式

    fileList.forEach(item => {
        if (Math.round(item.size / 1024 / 1024) > 100) {
            alert('文件内容超过100M，请重新上传')
            return
        }
    }, false)

    console.log(fileList)
})
```

# 3. 验证码 效果(canvas)

```javascript
// 随机数
const rn = (min, max) => {
    return Math.floor(Math.random() * (max - min) + min)
}

// 随机颜色
const rc = (min, max) => {
    let r = rn(min, max)
    let g = rn(min, max)
    let b = rn(min, max)

    return `rgb(${r}, ${g}, ${b})`
}

let w = 160
let h = 50
let pool = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'

let canvas = document.querySelector('canvas')
let ctx = canvas.getContext('2d')

canvas.width = w
canvas.height = h

canvas.onclick = function () {
    ctx.clearRect(0, 0, w, h)
    createCode()
}
canvas.click()

function createCode() {
    let randomWord = ''

    ctx.fillStyle = rc(50, 200)
    ctx.fillRect(0, 0, 200, 50)

    // 随机字符
    for (let i = 0; i < 4; i++) {
        // 随机字符
        let rw = pool[rn(0, 36)]
        randomWord += rw

        // 随机 字符大小
        let rf = rn(20, 40)

        // 随机 旋转角度
        let rDeg = rn(-30, 30)

        // 设置基线
        ctx.textBaseline = 'top'

        ctx.font = rf + 'px Simhei'

        ctx.fillStyle = rc(80, 200)
        ctx.save()

        ctx.translate(30 * i + 20, 15)
        ctx.rotate((rDeg * Math.PI) / 180)
        ctx.fillText(rw, 0, 0)

        ctx.restore()
    }

    // 随机生成 干扰线
    for (let i = 0; i < 4; i++) {
        ctx.beginPath()
        ctx.moveTo(rn(0, w), rn(0, h))
        ctx.lineTo(rn(0, w), rn(0, h))

        ctx.strokeStyle = rc(180, 230)
        ctx.stroke()
    }

    // 随机 小圆点
    for (let i = 0; i < 30; i++) {
        ctx.beginPath()
        ctx.arc(rn(0, w), rn(0, h), 1, 0, 2 * Math.PI)
        ctx.fillStyle = rc(100, 200)
        ctx.fill()
    }

    console.log(randomWord)
}
```

## 4. js 实现屏幕录制

```javascript
let btn = document.querySelector('button')
let video = document.querySelector('video')

btn.addEventListener('click', async () => {
    // 视频录制
    let stream = await navigator.mediaDevices.getDisplayMedia({
        video: true
    })

    // 需要更好的浏览器支持  判断是否支持
    const mime = MediaRecorder.isTypeSupported('video/webm; codecs=vp9') ? 'video/webm; codecs=vp9' : 'video/webm'

    let mediaRecorder = new MediaRecorder(stream, {
        mimeType: mime
    })

    let chunks = []

    mediaRecorder.addEventListener('dataavailable', e => {
        chunks.push(e.data)
    })

    // 停止录制
    mediaRecorder.addEventListener('stop', () => {
        let blob = new Blob(chunks, {
            type: chunks[0].type
        })
        let url = URL.createObjectURL(blob)

        video.src = url

        let a = document.createElement('a')
        a.href = url
        a.download = 'video/webm'
        a.click()
    })

    // 必须手动启动
    mediaRecorder.start()
})
```
